## Dynamic Programming

- 컴퓨터는 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이라는 점이 많은 제약을 발생시킨다. 그래서 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.
- 다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 피보나치 수열이 있다. 피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.
- n번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수
- 단, 1번째 피보나치 수 = 1, 2번째 피보나치 수 = 1
  ```
  #피보나치 함수를 재귀 함수로 표현
    def fibo(x):
      if x == 1 or x == 2:
        return 1
      return fibo(x-1) + fibo(x-2)
    
    print(fibo(4))

- 이처럼 피보나치 수열의 점화식을 재귀 함수를 사용해 만들 수는 있지만, 단순히 매번 계산하도록 하면 문제를 효율적으로 해결할 수 없다. 이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다. 다음 두 조건을 만족할 때 사용할 수 있다.
  1. 큰 문제를 작은 문제로 나눌 수 있다. 
  2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
- 메모이제이션은 다이나믹 프로그래밍을 구현하는 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다. 메모이제이션은 값을 저장하는 방법으로 캐싱이라고도 한다.
- 메모이제이션은 한 번 구한 정보를 리스트에 저장하는 식으로 구현할 수 있다.
  ```
  #한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
  d= [0] * 100
  
  def fibo(x):
    #종료 조건 (1 혹은 2일 때 1을 반환)
    if x == 1 or x ==2:
      return 1
    #이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
      return d[x]
    #아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]
  
  print(fibo(99))
  
- 정리하자면 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.
- 재귀함수를 이용하여 다이나믹 프로그래밍 소스를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운(Top-Down) 방식이라고 말한다.
  ```
  d= [0] * 100
  
  def pibo(x):
    print('f(' + str(x) + ')', end=' ')
    if x==1 or x==2:
      return 1
    if d[x]!=0:
      return d[x]
    d[x] = pibo(x-1) + pibo(x-2)
    return d[x]
  
  print(6)

- 반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업(Bottom-Up)방식이라고 말한다.
  ```
  d = [0]*100
   
  d[1]=1
  d[2]=2
  n=99
  
  for i in range(3, n+1):
    d[i]= d[i-1] + d[i-2]
  
  print(d[n])